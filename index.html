<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Mahjong Solitaire â€“ Final Release</title>
  <style>
    /* ====================== RESET & GLOBAL STYLES ====================== */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    /* Use flex on the body so the footer stays pinned to the bottom */
    body {
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      background-color: #121212;
      color: #e0e0e0;
      padding: 20px;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      overflow-x: hidden; /* hide horizontal scrollbar */
      text-align: center;
    }
    h1 {
      margin-bottom: 10px;
    }
    button {
      padding: 8px 16px;
      margin: 4px;
      font-size: 1rem;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      background-color: #28a745;
      color: #fff;
      transition: background-color 0.3s ease;
    }
    button:hover {
      background-color: #218838;
    }
    
    /* ====================== BOARD CONTAINER ====================== */
    /* The board-container holds all the tiles arranged by layers */
    #board-container {
      position: relative;
      margin: 0 auto;
      max-width: 800px;
      height: 600px;
      background-color: #2a2a2a;
      border: 2px solid #333;
    }
    
    /* ====================== TILE STYLING ====================== */
    .tile {
      position: absolute;
      width: 80px;
      height: 100px;
      background-color: #fff;
      border: 1px solid #888;
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.4rem;
      font-weight: bold;
      user-select: none;
      transition: opacity 0.3s ease;
      cursor: pointer;
    }
    /* Although Mahjong tiles are always faceup in solitaire,
       we include a .back style if needed */
    .tile.back {
      background-color: #444;
      border: 1px solid #222;
      color: #444;
    }
    /* A selected tile is highlighted */
    .tile.selected {
      outline: 3px solid #FFD700;
    }
    /* During drag, lower opacity */
    .dragging { opacity: 0.6; }
    /* Highlight dropable area */
    .drag-over { border: 2px dashed #FFD700; }
    
    /* ====================== MESSAGE AREA ====================== */
    #message {
      margin-top: 20px;
      padding: 8px;
      font-size: 1.1rem;
      position: relative;
      z-index: 10;
    }
    
    /* ====================== HELP MODAL ====================== */
    .modal {
      display: none;
      position: fixed;
      z-index: 10000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: auto;
      background-color: rgba(0, 0, 0, 0.8);
      padding: 20px;
    }
    .modal-content {
      background-color: #2a2a2a;
      margin: 10% auto;
      padding: 20px;
      border: 1px solid #888;
      width: 90%;
      max-width: 500px;
      border-radius: 6px;
      text-align: left;
      color: #e0e0e0;
    }
    .close {
      float: right;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
      color: #ccc;
    }
    .close:hover, .close:focus {
      color: #fff;
    }
    
    /* ====================== FOOTER ====================== */
    footer {
      margin-top: auto;
      padding: 10px 0;
      background-color: #1f1f1f;
      font-size: 0.9rem;
      color: #ccc;
      text-align: center;
    }
    
    /* ====================== RESPONSIVE STYLES ====================== */
    @media (max-width: 600px) {
      .tile {
        width: 60px;
        height: 75px;
        font-size: 1.1rem;
      }
      #board-container {
        max-width: 100%;
        height: 400px;
      }
    }
  </style>
</head>
<body>
  <!-- HEADER -->
  <header>
    <h1>Mahjong Solitaire</h1>
    <button id="helpBtn">Help</button>
    <button id="newGameBtn">New Game</button>
  </header>
  
  <!-- BOARD CONTAINER -->
  <div id="board-container"></div>
  
  <!-- MESSAGE AREA -->
  <div id="message"></div>
  
  <!-- FOOTER -->
  <footer>
    Â© 2025 Bocaletto Luca
  </footer>
  
  <!-- HELP MODAL -->
  <div id="helpModal" class="modal">
    <div class="modal-content">
      <span class="close" id="closeHelp">&times;</span>
      <h2>How to Play Mahjong Solitaire</h2>
      <p>
        <strong>Goal:</strong> Remove all matching pairs of tiles from the board.<br><br>
        <strong>Rules:</strong><br>
        - Tiles can be removed in pairs if they match exactly.<br>
        - A tile is considered <em>free</em> if it is not covered by any tile on a higher layer and if at least one of its left or right sides is unobstructed.<br>
        - Click a free tile to select it. Then click on a second free tile with the same symbol to remove both tiles.<br>
        - If the two selected tiles do not match, they are deselected.<br><br>
        Enjoy the game!
      </p>
    </div>
  </div>
  
  <!-- ====================== JAVASCRIPT ====================== -->
  <script>
    /***********************************************
     * Global Variables and Game State
     ***********************************************/
    let tiles = [];            // Array of tile objects
    let selectedTileId = null; // Currently selected tile id (if any)
    
    // Dimensions for each tile
    const TILE_WIDTH = 80;
    const TILE_HEIGHT = 100;
    
    /***********************************************
     * Board Layout Positions
     * We define a two-layer layout:
     * - Layer 0: 28 positions arranged in a 7x4 grid.
     * - Layer 1: 8 positions arranged in 2 rows of 4, centered.
     * Total positions = 36.
     ***********************************************/
    let positions = [];
    // Layer 0 positions: 7 columns x 4 rows = 28 tiles.
    for (let row = 0; row < 4; row++) {
      for (let col = 0; col < 7; col++) {
        positions.push({
          x: 50 + col * 100, // horizontal spacing
          y: 50 + row * 110, // vertical spacing
          z: 0,              // base layer
          width: TILE_WIDTH,
          height: TILE_HEIGHT
        });
      }
    }
    // Layer 1 positions: 2 rows x 4 columns = 8 tiles, centered.
    for (let row = 0; row < 2; row++) {
      for (let col = 0; col < 4; col++) {
        positions.push({
          x: 200 + col * 100, // centered horizontally
          y: 150 + row * 110, // vertical placement
          z: 1,              // upper layer
          width: TILE_WIDTH,
          height: TILE_HEIGHT
        });
      }
    }
    
    /***********************************************
     * Initialize the Game
     * - Use 18 unique Mahjong tile emojis, each appears twice.
     * - Total tiles = 36.
     ***********************************************/
    function initGame() {
      tiles = [];
      selectedTileId = null;
      document.getElementById("message").textContent = "";
      
      // 18 unique Mahjong tile emojis.
      let types = ["ðŸ€‡", "ðŸ€ˆ", "ðŸ€‰", "ðŸ€Š", "ðŸ€‹", "ðŸ€Œ", "ðŸ€", "ðŸ€Ž", "ðŸ€",
                   "ðŸ€", "ðŸ€‘", "ðŸ€’", "ðŸ€“", "ðŸ€”", "ðŸ€•", "ðŸ€–", "ðŸ€—", "ðŸ€˜"];
      // Create a list where each type appears twice.
      let tileTypes = [];
      types.forEach(type => {
        tileTypes.push(type);
        tileTypes.push(type);
      });
      shuffle(tileTypes);
      
      // Assign each tile a type and a position.
      for (let i = 0; i < positions.length; i++) {
        let pos = positions[i];
        let tile = {
          id: i,
          type: tileTypes[i],
          x: pos.x,
          y: pos.y,
          z: pos.z,
          width: pos.width,
          height: pos.height,
          removed: false
        };
        tiles.push(tile);
      }
      renderTiles();
    }
    
    // Fisherâ€“Yates Shuffle
    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }
    
    /***********************************************
     * Rendering Functions
     ***********************************************/
    function renderTiles() {
      let board = document.getElementById("board-container");
      board.innerHTML = "";
      // Sort tiles by layer (z-index) so that tiles in higher layers show on top.
      let sortedTiles = tiles.slice().sort((a, b) => a.z - b.z);
      
      sortedTiles.forEach(tile => {
        if (!tile.removed) {
          let tileDiv = document.createElement("div");
          tileDiv.className = "tile";
          // Add a selected CSS class if the tile is selected.
          if (tile.id === selectedTileId) {
            tileDiv.classList.add("selected");
          }
          tileDiv.textContent = tile.type;
          // Position the tile.
          tileDiv.style.left = tile.x + "px";
          tileDiv.style.top = tile.y + "px";
          tileDiv.style.zIndex = tile.z;
          // Add click handler for selection and matching.
          tileDiv.onclick = () => handleTileClick(tile.id);
          board.appendChild(tileDiv);
        }
      });
    }
    
    /***********************************************
     * Free Tile Detection
     * A tile is considered free if:
     * 1. No tile on a higher layer (greater z) overlaps it.
     * 2. At least one of its left or right sides is not blocked by another tile on the same layer.
     ***********************************************/
    function isTileFree(tile) {
      if (tile.removed) return false;
      
      // Check for overlap by any tile on a higher layer.
      for (let other of tiles) {
        if (!other.removed && other.z > tile.z) {
          if (isOverlap(tile, other)) {
            return false;
          }
        }
      }
      
      // Check horizontal free sides on the same layer.
      let leftBlocked = false;
      let rightBlocked = false;
      for (let other of tiles) {
        if (!other.removed && other.z === tile.z && other.id !== tile.id) {
          if (isTouchingLeft(tile, other)) leftBlocked = true;
          if (isTouchingRight(tile, other)) rightBlocked = true;
        }
      }
      return (!leftBlocked || !rightBlocked);
    }
    
    // Returns true if two tiles overlap (bounding box check)
    function isOverlap(tile1, tile2) {
      return (tile1.x < tile2.x + tile2.width &&
              tile1.x + tile1.width > tile2.x &&
              tile1.y < tile2.y + tile2.height &&
              tile1.y + tile1.height > tile2.y);
    }
    
    // Check if a tile touches the left side of another tile.
    function isTouchingLeft(tile, other) {
      if (other.x + other.width >= tile.x - 10 && other.x + other.width <= tile.x + 10) {
        return verticalOverlap(tile, other);
      }
      return false;
    }
    
    // Check if a tile touches the right side of another tile.
    function isTouchingRight(tile, other) {
      if (other.x <= tile.x + tile.width + 10 && other.x >= tile.x + tile.width - 10) {
        return verticalOverlap(tile, other);
      }
      return false;
    }
    
    // Check if the vertical spans of two tiles overlap.
    function verticalOverlap(tile, other) {
      return (tile.y < other.y + other.height && tile.y + tile.height > other.y);
    }
    
    /***********************************************
     * Tile Selection & Matching
     ***********************************************/
    function handleTileClick(tileId) {
      let tile = tiles.find(t => t.id === tileId);
      if (!tile || tile.removed) return;
      
      // Only allow selection if the tile is free.
      if (!isTileFree(tile)) {
        document.getElementById("message").textContent = "Tile is not free.";
        return;
      }
      
      // If no tile is selected yet, select this tile.
      if (selectedTileId === null) {
        selectedTileId = tileId;
        document.getElementById("message").textContent = "Selected tile " + tile.type + ". Select a matching free tile.";
        renderTiles();
      }
      // If a tile was already selected, check for a match.
      else {
        let firstTile = tiles.find(t => t.id === selectedTileId);
        if (firstTile.id === tile.id) {
          // User clicked the same tile â€“ deselect.
          selectedTileId = null;
          document.getElementById("message").textContent = "";
          renderTiles();
          return;
        }
        // If types match, remove both tiles.
        if (firstTile.type === tile.type) {
          firstTile.removed = true;
          tile.removed = true;
          document.getElementById("message").textContent = "Matched " + tile.type + " pair!";
          selectedTileId = null;
          renderTiles();
          checkWinCondition();
        } else {
          // Mismatch: clear selection.
          document.getElementById("message").textContent = "Tiles do not match. Try again.";
          selectedTileId = null;
          renderTiles();
        }
      }
    }
    
    /***********************************************
     * Win Condition
     ***********************************************/
    function checkWinCondition() {
      let remaining = tiles.filter(t => !t.removed).length;
      if (remaining === 0) {
        document.getElementById("message").textContent = "Congratulations! You win!";
      }
    }
    
    /***********************************************
     * Event Handlers for UI Buttons and Help Modal
     ***********************************************/
    document.getElementById("newGameBtn").onclick = function() {
      initGame();
    };
    document.getElementById("helpBtn").onclick = function() {
      document.getElementById("helpModal").style.display = "block";
    };
    document.getElementById("closeHelp").onclick = function() {
      document.getElementById("helpModal").style.display = "none";
    };
    window.onclick = function(e) {
      if (e.target === document.getElementById("helpModal")) {
        document.getElementById("helpModal").style.display = "none";
      }
    };
    
    /***********************************************
     * Initialize the Game
     ***********************************************/
    initGame();
  </script>
</body>
</html>
